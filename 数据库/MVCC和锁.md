### 事务：

​	需要保证`原子性`、`隔离性`、`一致性`和`持久性`的一个或多个数据库操作称之为一个`事务` 。

### 事务的隔离级别：

1. 脏读
   1. 读取到了一个事务读到另一个事务未提交的数据。
2. 不可重复读
   1. 如果一个事务只能读到另一个已经提交的事务修改过的数据，并且其他事务每对该数据进行一次修改并提交后，该事务都能查询得到最新值，那就意味着发生了不可重复读
3. 幻读
   1. 同样的查询条件，多次查询，幻读只是重点强调了读取到了之前读取没有获取到的记录。区间的概念。

![img](https://docimg1.docs.qq.com/image/bqt2gnQCApKaoN_AJBChXQ?w=886&h=235)

#### MVCC

历史版本是根据UnDo日志构建的。

解决脏读：

​	生成ReadView的时机：READ COMMITTED隔离级别的事务在每次查询开始时都会生成一个独立的ReadView。

解决不可重复读以及幻读：

​	在事务第一次读取数据的时候生成readview。

在特定的隔离级别下，可以使读写事务并发的执行。

ReadView的生成：

- `m_ids`：表示在生成`ReadView`时当前系统中活跃的读写事务的`事务id`列表。
- `min_trx_id`：表示在生成`ReadView`时当前系统中活跃的读写事务中最小的`事务id`，也就是`m_ids`中的最小值。
- `max_trx_id`：表示生成`ReadView`时系统中应该分配给下一个事务的`id`值。

````|
|
|		已提交	  当前活跃事务      未提交
|    |________|_______________|__________|
         min_trx_id    max_trx_id
          低水位          高水位

````

`只有在第一次真正修改记录时（比如使用INSERT、DELETE、UPDATE语句），才会被分配一个单独的事务id，这个事务id是递增的。`

更新的时候都是先读后写，且为`当前读`。



#### 锁

##### 锁结构：

- `trx信息`：代表这个锁结构是哪个事务生成的。
- `is_waiting`：代表当前事务是否在等待。



 共享锁（shared S锁）行级锁 

 IS 意向共享锁（表级锁），在加S锁之前，先加一个IS锁，

独占锁（X锁）

 IX 意向共享锁（表级锁），在加X锁之前，先加一个IX锁，

- 对读取的记录加`S锁`：

  ```sql
  SELECT ... LOCK IN SHARE MODE;
  ```

- 对读取的记录加`X锁`：

  ```sql
  SELECT ... FOR UPDATE;
  ```

##### Innodb的表级锁：

1、表级别的`IS锁`、`IX锁`

​	为了更方便的判断表中是否有记录加锁。

2、AUTO-INC

​	为某个列加上 `AUTO_INCREMENT`属性时，在插入新数据时，会对表加`AUTO-INC`锁。

​	获取到`AUTO_INCREMENT`属性列的值后，就可以释放锁。

#### innodb 行级锁：

##### 1、单行锁：

##### 2、区间锁 间隙锁（gap锁）：防止产生幻影记录

​	插入意向锁（Insert Intention Locks）：

##### 3、Insert 的隐式锁：

​	在插入前，如果即将插入的区间被其他事务加上了gap锁，那么本次插入操作会阻塞，并会加上插入意向锁。

​	如果一个事务插入一条数据，但是其他的事务使用select语句读取这条数据。

​	此时事务id就起到作用了，

​	对于聚簇索引记录来说，每个记录都保存了最后改动这条数据的事务id。

​	二级索引页面的`Page Header`部分有一个`PAGE_MAX_TRX_ID`属性，该属性代表对该页面做改动的最大的`事务id`

##### 4、加锁规则：

* 原则 1：加锁的基本单位是 next-key lock。，next-key lock 是前开后闭区间。

* 原则 2：查找过程中访问到的对象才会加锁。

* 优化 1：索引上的等值查询，给唯一索引加锁的时候，next-key lock 退化为行锁。

* 优化 2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock 退化为间隙锁。

* 一个 bug：唯一索引上的范围查询会访问到不满足条件的第一个值为止。

````
select * from t where id > 10 and id <= 15 for update;
````







#### 数据库的三种写操作：

一条数据库语句执行使用到什么锁，有很多条件制约，比方说：

- 事务的隔离级别
- 语句执行时使用的索引（比如聚簇索引、唯一二级索引、普通二级索引）
- 查询条件（比方说`=`、`=<`、`>=`等等）
- 具体执行的语句类型

##### 1、Delete:

​	定位到这条记录，获取这行记录的X锁，之后然后再执行`delete mark`操作。

##### 2、Update

三种情况：

​	a、如果未修改该记录的键值并且被更新的列占用的存储空间在修改前后未发生变化，则先在`B+`树中定位到这条记录的位置，然后再获取一下记录的`X锁`，最后在原记录的位置进行修改操作。其实我们也可以把这个定位待修改记录在`B+`树中位置的过程看成是一个获取`X锁`的`锁定读`。

​	b、如果未修改该记录的键值并且至少有一个被更新的列占用的存储空间在修改前后发生变化，则先在`B+`树中定位到这条记录的位置，然后获取一下记录的`X锁`，将该记录彻底删除掉（就是把记录彻底移入垃圾链表），最后再插入一条新记录。这个定位待修改记录在`B+`树中位置的过程看成是一个获取`X锁`的`锁定读`，新插入的记录由`INSERT`操作提供的`隐式锁`进行保护

​	c、如果修改了该记录的键值，则相当于在原记录上做`DELETE`操作之后再来一次`INSERT`操作，加锁操作就需要按照`DELETE`和`INSERT`的规则进行了。

##### 3、Insert

​	一般情况下，新插入一条记录的操作并不加锁，通过一种称之为`隐式锁`来保护这条新插入的记录在本事务提交前不被别的事务访问。

​	

| 事务隔离级别    | SELECT                                         | UPDATE | DELETE |
| --------------- | ---------------------------------------------- | ------ | ------ |
| READ UNCOMMITED | 不加锁，直接读取最新记录                       |        |        |
| READ COMMITED   | 不加锁，每次select生成一个ReadView             |        |        |
| REPEATABLE READ | 不加锁，事务第一次执行select前生成一个ReadView |        |        |

- select的特殊情况：
  - **autocommit : 如果不显式的使用`START TRANSACTION`或者`BEGIN`语句开启一个事务，那么每一条语句都算是一个独立的事务，这种特性称之为事务的`自动提交`。**
  - 在系统变量`autocommit=0`时，也就是禁用自动提交时，普通的`SELECT`语句会被转为`SELECT ... LOCK IN SHARE MODE`这样的语句，也就是在读取记录前需要先获得记录的`S锁`，具体的加锁情况和`REPEATABLE READ`隔离级别下一样，我们后边再分析。
  - 在系统变量`autocommit=1`时，也就是启用自动提交时，普通的`SELECT`语句并不加锁，只是利用`MVCC`来生成一个`ReadView`去读取记录。
  - 使用二级索引的select：
    - 1、查找二级索引上的符合条件的记录，并对其二级索引添加S锁，在对其对应的聚簇索引加S锁。
    - 

