#### mysql 索引

<img src="picture/image-20201201160730321.png" alt="image-20201201160730321" style="zoom:67%;" />

##### innodb:

​	使用页（16KB）来作为管理存储空间的基本单位，底层数据结构为B+树。

* 实际用户记录其实都存放在B+树的最底层的节点上，这些节点也被称为`叶子节点`或`叶节点`，其余用来存放`目录项`的节点称为`非叶子节点`或者`内节点`，其中`B+`树最上边的那个节点也称为`根节点`。

 * record_type: 记录头信息的一项属性，表示记录的类型，
     * `0`表示普通记录
     * `2`表示最小记录
     * `3`表示最大记录
     * `1`表示目录项

##### 索引分类：

 * 聚簇索引

    * 没有主键，InnoDB 会找一个唯一索引列作为主键索引，只有主键索引(聚簇索引)生成的B+树，才会保存完整的用户记录，InnoDB 必须有一个聚簇索引
    * 以主键构建的b+树，叶子节点保存的是完整的数据记录。
      	* 页内的记录是按照主键的大小顺序排成一个单向链表。
      * 各个存放用户记录的页也是根据页中用户记录的主键大小顺序排成一个双向链表。
      * 存放目录项记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键大小顺序排成一个双向链表。

 * 二级索引

    * 以数据表中非主键列构建的索引，叶子节点保存的是用户记录的主键。
       * 实际是以 索引列值+主键构成，防止索引列值重复导致内节点目录项
       
       * 查找到某条数据之后，需要回表，拿到完整信息返回给客户端。
       
         ![image_1cthurrlpbhlotsjru1dsjrrl30.png-110.2kB](https://user-gold-cdn.xitu.io/2019/5/3/16a7b843e05c8e33?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

 * 联合索引

    * 多个索引列构建的索引

##### B+ 树适用的条件

````sql
CREATE TABLE person_info(
    id INT NOT NULL auto_increment,
    name VARCHAR(100) NOT NULL,
    birthday DATE NOT NULL,
    phone_number CHAR(11) NOT NULL,
    country varchar(100) NOT NULL,
    PRIMARY KEY (id),
    KEY idx_name_birthday_phone_number (name, birthday, phone_number)
);
````

 * 全值匹配

   	* 索引列全值匹配

* 匹配左边的列

* 匹配列前缀 

* 匹配范围值

* 排序

  * 对于`联合索引`有个问题需要注意，`ORDER BY`的子句后边的列的顺序也必须按照索引列的顺序给出，如果给出`ORDER BY phone_number, birthday, name`的顺序，那也是用不了`B+`树索引，这种颠倒顺序就不能使用索引

  
  
##### 索引的使用

* 只为用于搜索、排序或分组的列创建索引
  
* 只为出现在`WHERE`子句中的列、连接子句中的连接列，或者出现在`ORDER BY`或`GROUP BY`子句中的列创建索引。而出现在查询列表中的列就没必要建立索引了
  
* 列的数据重复数量小的列

* 索引列的类型尽量小
  * 数据类型越小，在查询时进行的比较操作越快（这是CPU层次的东东）
  * 数据类型越小，索引占用的存储空间就越少，在一个数据页内就可以放下更多的记录，从而减少磁盘`I/O`带来的性能损耗，也就意味着可以把更多的数据页缓存在内存中，从而加快读写效率。
  
* 索引字符串值的前缀

   * 如果使用了索引列前缀，比方说前边只把`name`列的前10个字符放到了二级索引中，下边这个查询可能就有点儿尴尬了：
   
   ```
   SELECT * FROM person_info ORDER BY name LIMIT 10;
   
   因为二级索引中不包含完整的`name`列信息，所以无法对前十个字符相同，后边的字符不同的记录进行排序，也就是使用索引列前缀的方式无法支持使用索引排序，只好乖乖的用文件排序喽。
   ```
   
* 让索引列在比较表达式中单独出现
  
  * 如果索引列在比较表达式中不是以单独列的形式出现，而是以某个表达式，或者函数调用形式出现的话，是用不到索引的。
  
  ##### 主键插入顺序
  
   主键递增的插入数据表
  
  <img src="https://user-gold-cdn.xitu.io/2019/10/9/16db02bc77059366?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image_1capq7nnv13en8b31lvtj2i1e8lm.png-35.3kB" style="zoom:50%;" />
  
  主键为9的这条数据插入时，我们需要把当前页面分裂成两个页面，把本页中的一些记录移动到新创建的这个页中。页面分裂和记录移位意味着什么？意味着：性能损耗！所以如果我们想尽量避免这样无谓的性能损耗，最好让插入的记录的主键值依次递增，这样就不会发生这样的性能损耗了。所以我们建议：让主键具有`AUTO_INCREMENT`，让存储引擎自己为表生成主键，而不是我们手动插入

##### 不适用索引的场景：

​	对索引字段做函数操作，可能会破坏索引值的有序性，因此优化器就决定放弃走树搜索功能。