#### 1、使用Redis来实现。

* RedLock,和大多数的分布式共识算法一样，采用大多数的机制，集群中大多数的节点加锁成功，才算成功。

存在的缺陷：

​	1、进程持有锁之后，进入GC 或者在调用共享服务资源时网络超时，导致持有锁超时，其他进程获取到锁，这样会导致同时有两个进程会对共享资源进行操作。

解决方案：

​	使用一个递增的序列号，共享的资源服务，会判断当前持有锁的进程序列号是否是过期的序列号。

#### 2、zookeeper

相比较于1的实现：

​	客户端和分布式锁服务之间存在Session，而且会和客户端之间一直保持心跳，zookeeper在判断到客户端下线后，会释放锁，而如果客户端正常的话，会正常释放锁。

羊群效应

​	锁释放后，会通知所有正在等待的节点，所有节点都会判断自身序号是否最小，

解决方案：

​	只需要watch比自己小的那个节点的通知事件即可。



#### 3、Chubby解决方案：

##### 	1、调用Chubby提供的API来检查序列号的有效性。

##### 	2、共享资源检查将客户端传来的序列号和自己观察到最新的序列号做对比，只有最新的才能操做。

##### 	3、lock-delay。Chubby允许客户端为持有的锁指定一个lock-delay的时间值（默认是1分钟）。当Chubby发现客户端被动失去联系的时候，并不会立即释放锁，而是会在lock-delay指定的时间内阻止其它客户端获得这个锁。这是为了在把锁分配给新的客户端之前，让之前持有锁的客户端有充分的时间把请求队列排空(draining the queue)，尽量防止出现延迟到达的未处理请求。